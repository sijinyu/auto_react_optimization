This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-16T04:52:04.440Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  __tests__/
    analyzer.test.ts
  analyzer/
    componentAnalyzer.ts
    hooks.ts
    metrics.ts
    renderAnalysis.ts
  optimizer/
    rules/
      defaultRules.ts
      index.ts
    index.ts
  rules/
    react-hooks-optimization.ts
  types/
    index.ts
  utils/
    analyzerUtils.ts
    astUtils.ts
    index.ts
  index.ts
.babelrc
.gitignore
.npmignore
jest.config.js
package.json
README.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/__tests__/analyzer.test.ts
================
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import { analyzeComponent } from '../analyzer/componentAnalyzer';
import { AnalyzerConfig } from '../types';

describe('Component Analyzer', () => {
  const defaultConfig: AnalyzerConfig = {
    memoThreshold: {
      propsCount: 2,
      renderCount: 3,
    },
    performanceThreshold: {
      complexity: 5,
      arraySize: 100,
      computationWeight: 0.7,
    },
  };

  test('should analyze a simple component with expensive calculation', () => {
    const code = `
      function ExpensiveComponent() {
        const result = new Array(1000).fill(0).map((_, i) => i * 2);
        
        return (
          <div>{result.join(',')}</div>
        );
      }
    `;

    const ast = parse(code, {
      sourceType: 'module',
      plugins: ['jsx', 'typescript'],
    });

    traverse(ast, {
      FunctionDeclaration(path) {
        const analysis = analyzeComponent(path, 'test.tsx', defaultConfig);

        expect(analysis.name).toBe('ExpensiveComponent');
        expect(analysis.renderAnalysis.hasExpensiveOperations).toBe(true);
      },
    });
  });

  test('should analyze a component with event handlers', () => {
    const code = `
      function EventComponent() {
        const handleClick = () => {
          console.log('clicked');
        };
        
        return (
          <button onClick={handleClick}>
            Click me
          </button>
        );
      }
    `;

    const ast = parse(code, {
      sourceType: 'module',
      plugins: ['jsx', 'typescript'],
    });

    traverse(ast, {
      FunctionDeclaration(path) {
        const analysis = analyzeComponent(path, 'test.tsx', defaultConfig);

        expect(analysis.name).toBe('EventComponent');
        expect(analysis.renderAnalysis.hasEventHandlers).toBe(true);
        expect(analysis.renderAnalysis.eventHandlers.length).toBe(1);
      },
    });
  });
  describe('Advanced Component Analysis', () => {
    test('should analyze nested components with prop passing', () => {
      const code = `
        function ParentComponent() {
          const handleClick = () => {
            console.log('clicked');
          };
  
          const data = new Array(1000).fill(0).map((_, i) => i * 2);
  
          return (
            <div>
              <ChildComponent 
                onClick={handleClick}
                data={data}
                onHover={() => console.log('hover')}
              />
            </div>
          );
        }
      `;

      const ast = parse(code, {
        sourceType: 'module',
        plugins: ['jsx', 'typescript'],
      });

      traverse(ast, {
        FunctionDeclaration(path) {
          const analysis = analyzeComponent(path, 'test.tsx', defaultConfig);

          expect(analysis.name).toBe('ParentComponent');
          expect(analysis.renderAnalysis.hasChildComponents).toBe(true);
          expect(analysis.renderAnalysis.hasExpensiveOperations).toBe(true);
          expect(analysis.renderAnalysis.functionPropPassing).toBe(true);
        },
      });
    });

    test('should analyze components with hooks', () => {
      const code = `
        function HookComponent() {
          const [count, setCount] = useState(0);
          const [data, setData] = useState([]);
    
          useEffect(() => {
            const newData = heavyCalculation();
            setData(newData); // 실제로 setState 호출하는 부분
          }, []);
    
          useEffect(() => {
            console.log(count);
          });
    
          const handleClick = () => {
            setCount(prev => prev + 1); // 실제로 setState 호출하는 부분
          };
    
          return (
            <button onClick={handleClick}>
              Count: {count}
            </button>
          );
        }
    
        function heavyCalculation() {
          return new Array(1000).fill(0).map((_, i) => i * 2);
        }
      `;

      const ast = parse(code, {
        sourceType: 'module',
        plugins: ['jsx', 'typescript'],
      });

      traverse(ast, {
        FunctionDeclaration(path) {
          if (path.node.id?.name === 'HookComponent') {
            const analysis = analyzeComponent(path, 'test.tsx', defaultConfig);

            expect(analysis.hooks.length).toBe(4); // useState 2개, useEffect 2개
            expect(analysis.renderAnalysis.hasStateUpdates).toBe(true); // setState 호출 확인
            expect(analysis.renderAnalysis.hasEventHandlers).toBe(true); // 이벤트 핸들러 확인
          }
        },
      });
    });
  });
});

================
File: src/analyzer/componentAnalyzer.ts
================
import { NodePath } from '@babel/traverse';
import * as t from '@babel/types';
import { AnalyzerConfig, ComponentAnalysis } from '../types';
import { getComponentName } from '../utils';
import { analyzeProps } from '../utils/analyzerUtils';
import { isHook } from '../utils/astUtils';
import { analyzeHooks } from './hooks';
import { calculateComplexity } from './metrics';
import { analyzeRenderingBehavior } from './renderAnalysis';

export function analyzeComponent(
  path: NodePath,
  filePath: string,
  config: AnalyzerConfig
): ComponentAnalysis {
  // React 컴포넌트인지 확인
  const name = getComponentName(path);

  if (!name) {
    throw new Error('Not a valid React component');
  }

  const analysis: ComponentAnalysis = {
    name,
    filePath,
    props: analyzeProps(path),
    hooks: analyzeHooks(path),
    complexity: calculateComplexity(path),
    renderAnalysis: analyzeRenderingBehavior(path, config),
    dependencies: analyzeDependencies(path),
  };
  validateAnalysis(analysis);
  return analysis;
}

function analyzeDependencies(path: NodePath): string[] {
  const dependencies = new Set<string>();

  path.traverse({
    ImportDeclaration(importPath: NodePath<t.ImportDeclaration>) {
      const source = importPath.node.source.value;
      if (!source.startsWith('.') && !source.startsWith('/')) {
        dependencies.add(source);
      }
    },
    CallExpression(callPath: NodePath<t.CallExpression>) {
      if (isHook(callPath)) {
        dependencies.add('react');
      }
    },
  });

  return Array.from(dependencies);
}

function validateAnalysis(analysis: ComponentAnalysis): void {
  if (!analysis.name) {
    throw new Error('Component analysis must have a name');
  }
  if (!analysis.props) {
    throw new Error('Component analysis must include props analysis');
  }
  if (!analysis.hooks) {
    throw new Error('Component analysis must include hooks analysis');
  }
}

================
File: src/analyzer/hooks.ts
================
import { NodePath } from '@babel/traverse';
import * as t from '@babel/types';
import { HookInfo, HookType } from '../types';
import { getHookDependencies, HOOK_TYPES, isHook } from '../utils/astUtils';

export function analyzeHooks(path: NodePath): HookInfo[] {
  const hooks: Set<HookInfo> = new Set();
  const analyzedHooks = new Set<string>();

  path.traverse({
    CallExpression(callPath) {
      if (!isHook(callPath)) return;
      const node = callPath.node;
      const hookName = (node.callee as t.Identifier).name;

      // 중복 분석 방지
      const hookSignature = generateHookSignature(callPath);
      if (analyzedHooks.has(hookSignature)) return;
      analyzedHooks.add(hookSignature);

      // useCallback인 경우 감싸고 있는 함수 이름 찾기
      let wrappedFunction;
      if (hookName === 'useCallback') {
        const parent = callPath.findParent((p) =>
          t.isVariableDeclarator(p.node)
        );
        if (parent?.isVariableDeclarator() && t.isIdentifier(parent.node.id)) {
          wrappedFunction = parent.node.id.name;
        }
      }

      hooks.add({
        name: hookName,
        type: determineHookType(hookName),
        dependencies: getHookDependencies(callPath),
        complexity: calculateHookComplexity(callPath),
        wrappedFunction,
      });
    },
  });

  return Array.from(hooks);
}

function generateHookSignature(path: NodePath<t.CallExpression>): string {
  const node = path.node;
  const loc = node.loc;

  return `${(node.callee as t.Identifier).name}:${loc?.start.line}:${
    loc?.start.column
  }`;
}

function determineHookType(hookName: string): HookType {
  switch (hookName) {
    case HOOK_TYPES.STATE:
      return 'useState';
    case HOOK_TYPES.EFFECT:
      return 'useEffect';
    case HOOK_TYPES.MEMO:
      return 'useMemo';
    case HOOK_TYPES.CALLBACK:
      return 'useCallback';
    case HOOK_TYPES.REF:
      return 'useRef';
    case HOOK_TYPES.CONTEXT:
      return 'useContext';
    case HOOK_TYPES.REDUCER:
      return 'useReducer';
    default:
      return 'custom';
  }
}

function calculateHookComplexity(path: NodePath<t.CallExpression>): number {
  let complexity = 1;
  const callback = path.node.arguments[0];

  // Hook이 콜백을 받지 않는 경우 (예: useRef)
  if (!callback || !t.isFunction(callback)) {
    return complexity;
  }

  // 콜백 함수의 복잡도 분석
  const callbackPath = path.get('arguments.0') as NodePath<t.Function>;

  if (callbackPath) {
    callbackPath.traverse({
      // 조건문
      IfStatement() {
        complexity++;
      },
      // 반복문
      'ForStatement|WhileStatement|DoWhileStatement'() {
        complexity += 2;
      },
      // 삼항 연산자
      ConditionalExpression() {
        complexity++;
      },
      // 논리 연산자
      LogicalExpression() {
        complexity++;
      },
      // API 호출
      CallExpression(callPath: NodePath<t.CallExpression>) {
        if (isStateUpdate(callPath)) {
          complexity++;
        }
      },
      // 상태 업데이트
      MemberExpression(memberPath: NodePath<t.MemberExpression>) {
        if (isStateUpdate(memberPath)) {
          complexity++;
        }
      },
    });
  }

  // 의존성 배열 분석
  const dependencies = getHookDependencies(path);
  complexity += Math.ceil(dependencies.length / 3);

  return complexity;
}

export function isStateUpdate(
  path: NodePath<t.MemberExpression | t.CallExpression>
): boolean {
  // MemberExpression인 경우 (예: this.setState)
  if (path.isMemberExpression()) {
    const property = path.node.property;
    return t.isIdentifier(property) && property.name === 'setState';
  }

  // CallExpression인 경우 (예: setCount(1))
  if (path.isCallExpression()) {
    return isStateUpdateCall(path);
  }

  return false;
}

export function isStateUpdateCall(path: NodePath<t.CallExpression>): boolean {
  const callee = path.node.callee;
  if (!t.isIdentifier(callee)) return false;

  // useState의 setter 함수 체크
  const binding = path.scope.getBinding(callee.name);
  if (binding?.path.parentPath?.isVariableDeclarator()) {
    const init = (binding.path.parentPath.node as t.VariableDeclarator).init;
    if (
      t.isCallExpression(init) &&
      t.isIdentifier(init.callee) &&
      init.callee.name === HOOK_TYPES.STATE
    ) {
      return true;
    }
  }

  return false;
}

export function validateHookRules(path: NodePath): string[] {
  const violations: string[] = [];
  let isInsideLoop = false;
  let isInsideCondition = false;
  let hookCallOrder: string[] = [];

  path.traverse({
    'ForStatement|WhileStatement|DoWhileStatement'(path) {
      isInsideLoop = true;
      path.traverse({
        CallExpression(callPath) {
          if (isHook(callPath)) {
            violations.push(
              `Hook "${
                (callPath.node.callee as t.Identifier).name
              }" is called inside a loop`
            );
          }
        },
      });
      isInsideLoop = false;
    },

    IfStatement(path) {
      isInsideCondition = true;
      path.traverse({
        CallExpression(callPath) {
          if (isHook(callPath)) {
            violations.push(
              `Hook "${
                (callPath.node.callee as t.Identifier).name
              }" is called inside a condition`
            );
          }
        },
      });
      isInsideCondition = false;
    },

    CallExpression(callPath) {
      if (!isHook(callPath)) return;

      const hookName = (callPath.node.callee as t.Identifier).name;

      // Hook 호출 순서 체크
      if (!isInsideLoop && !isInsideCondition) {
        hookCallOrder.push(hookName);
      }
    },
  });

  // Hook 순서 일관성 체크
  if (!validateHookCallOrder(hookCallOrder)) {
    violations.push('Hooks are called in inconsistent order');
  }

  return violations;
}

function validateHookCallOrder(hookOrder: string[]): boolean {
  return !hookOrder.some((hook, index) => hookOrder.indexOf(hook) !== index);
}

================
File: src/analyzer/metrics.ts
================
import { NodePath } from "@babel/traverse";
import * as t from "@babel/types";
import { ComplexityMetrics } from "../types";
import { isHook } from "../utils/astUtils";

export function calculateComplexity(path: NodePath): ComplexityMetrics {
  return {
    cyclomaticComplexity: calculateCyclomaticComplexity(path),
    cognitiveComplexity: calculateCognitiveComplexity(path),
    linesOfCode: calculateLinesOfCode(path),
    dependencies: calculateDependencies(path),
  };
}

function calculateCyclomaticComplexity(path: NodePath): number {
  let complexity = 1; // 기본 복잡도

  path.traverse({
    IfStatement() {
      complexity++;
    },
    SwitchCase() {
      complexity++;
    },
    LogicalExpression({ node }) {
      if (node.operator === "&&" || node.operator === "||") {
        complexity++;
      }
    },
    ForStatement() {
      complexity++;
    },
    WhileStatement() {
      complexity++;
    },
    DoWhileStatement() {
      complexity++;
    },
    TryStatement(tryPath) {
      complexity++; // try 블록
      complexity += tryPath.node.handler ? 1 : 0; // catch 블록
      complexity += tryPath.node.finalizer ? 1 : 0; // finally 블록
    },
  });

  return complexity;
}

function calculateCognitiveComplexity(path: NodePath): number {
  let complexity = 0;
  let depthModifier = 0;

  path.traverse({
    "IfStatement|WhileStatement|ForStatement|DoWhileStatement"(statementPath) {
      // 중첩 레벨에 따라 가중치 부여
      complexity += 1 + depthModifier;
      depthModifier++;

      statementPath.traverse({
        "IfStatement|WhileStatement|ForStatement|DoWhileStatement"() {
          complexity += 1 + depthModifier;
        },
      });

      depthModifier--;
    },
    ConditionalExpression() {
      complexity += 1;
    },
    LogicalExpression({ node }) {
      if (node.operator === "&&" || node.operator === "||") {
        complexity += 1;
      }
    },
  });

  return complexity;
}

function calculateLinesOfCode(path: NodePath): number {
  const code = path.toString();
  return code.split("\n").length;
}

function calculateDependencies(path: NodePath): number {
  const dependencies = new Set<string>();

  path.traverse({
    ImportDeclaration(importPath) {
      dependencies.add(importPath.node.source.value);
    },
    CallExpression(callPath: NodePath<t.CallExpression>) {
      if (isHook(callPath)) {
        dependencies.add("react");
      }
    },
  });

  return dependencies.size;
}

================
File: src/analyzer/renderAnalysis.ts
================
import { NodePath } from '@babel/traverse';
import * as t from '@babel/types';
import {
  AnalyzerConfig,
  ChildComponent,
  EventHandler,
  RenderAnalysis,
} from '../types';
import { HOOK_TYPES, isHook, isSpecificHook } from '../utils/astUtils';
import { isStateUpdate } from './hooks';

export function analyzeRenderingBehavior(
  path: NodePath,
  config: AnalyzerConfig
): RenderAnalysis {
  let hasChildComponents = false;
  let hasPropsPassingToChild = false;

  path.traverse({
    JSXElement(jsxPath) {
      const openingElement = jsxPath.node.openingElement;
      const elementName = openingElement.name;

      // 대문자로 시작하는 컴포넌트 이름 체크
      if (
        t.isJSXIdentifier(elementName) &&
        elementName.name[0] === elementName.name[0].toUpperCase()
      ) {
        hasChildComponents = true;

        openingElement.attributes.forEach((attr) => {
          if (t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name)) {
            const attrName = attr.name.name; // name 프로퍼티의 실제 문자열 값
            const value = attr.value;

            if (t.isJSXExpressionContainer(value)) {
              const expression = value.expression;
              if (
                t.isFunction(expression) ||
                (t.isIdentifier(expression) &&
                  (attrName.startsWith('handle') || attrName.startsWith('on')))
              ) {
                hasPropsPassingToChild = true;
              }
            }
          }
        });
      }
    },
  });

  const analysis: RenderAnalysis = {
    estimatedRenderCount: calculateEstimatedRenderCount(path),
    hasExpensiveCalculations: checkForExpensiveCalculations(path, config),
    hasExpensiveOperations: checkForExpensiveOperations(path, config),
    affectedByStateChanges: checkForStateChanges(path),
    eventHandlers: findEventHandlers(path),
    hasEventHandlers: false,
    hasChildComponents: hasChildComponents && hasPropsPassingToChild,
    memoizedComponents: findMemoizedComponents(path),
    functionPropPassing: false,
    hasStateUpdates: false,
  };

  // 부가 정보 설정
  analysis.hasEventHandlers = analysis.eventHandlers.length > 0;
  analysis.functionPropPassing = checkForFunctionPropPassing(path);
  analysis.hasStateUpdates = checkForStateUpdates(path);

  return analysis;
}

function calculateEstimatedRenderCount(path: NodePath): number {
  let count = 1; // 초기 렌더링

  path.traverse({
    CallExpression(callPath) {
      const node = callPath.node;
      if (!isHook(node)) return;

      if (isSpecificHook(node, HOOK_TYPES.STATE)) {
        count += 2; // setState 호출 가능성
      } else if (isSpecificHook(node, HOOK_TYPES.EFFECT)) {
        count += 1; // effect 재실행 가능성
      }
    },
  });

  return count;
}

function checkForExpensiveCalculations(
  path: NodePath,
  config: AnalyzerConfig
): boolean {
  let found = false;
  const threshold = config.performanceThreshold.complexity; // 기본값: 5
  // 루프의 복잡도 체크

  path.traverse({
    ForStatement(forPath) {
      if (calculateLoopComplexity(forPath) > threshold) {
        found = true;
      }
    },
    WhileStatement(whilePath) {
      if (calculateLoopComplexity(whilePath) > threshold) {
        found = true;
      }
    },
  });

  return found;
}

function checkForExpensiveOperations(
  path: NodePath,
  config: AnalyzerConfig
): boolean {
  let found = false;
  const arrayThreshold = config.performanceThreshold.arraySize;

  path.traverse({
    // 1. 변수 선언 체크
    VariableDeclarator(declaratorPath) {
      const init = declaratorPath.get('init');
      if (!init) return;

      if (checkForArrayOperations(init as NodePath)) {
        if (!isMemoized(declaratorPath)) {
          found = true;
        }
      }
    },

    // 2. 함수 표현식 및 화살표 함수 반환 값 체크
    ArrowFunctionExpression(arrowPath) {
      const body = arrowPath.get('body');

      if (checkForArrayOperations(body)) {
        if (!isMemoized(arrowPath)) {
          found = true;
        }
      }
    },

    // 3. 일반 함수 선언에서 내부의 배열 생성 여부 탐지
    FunctionDeclaration(funcPath) {
      funcPath.traverse({
        CallExpression(callPath) {
          if (checkForArrayOperations(callPath)) {
            if (!isMemoized(callPath)) {
              found = true;
            }
          }
        },
        NewExpression(newPath) {
          if (checkForArrayOperations(newPath)) {
            if (!isMemoized(newPath)) {
              found = true;
            }
          }
        },
      });
    },

    // 4. 함수 표현식에서도 배열 생성 및 메서드 사용 체크
    FunctionExpression(funcExprPath) {
      funcExprPath.traverse({
        CallExpression(callPath) {
          if (checkForArrayOperations(callPath)) {
            if (!isMemoized(callPath)) {
              found = true;
            }
          }
        },
        NewExpression(newPath) {
          if (checkForArrayOperations(newPath)) {
            if (!isMemoized(newPath)) {
              found = true;
            }
          }
        },
      });
    },
  });

  return found;

  // Helper 함수: 배열 연산 여부 체크
  function checkForArrayOperations(nodePath: NodePath): boolean {
    if (nodePath.isCallExpression() || nodePath.isNewExpression()) {
      const calleeNode = nodePath.node.callee;

      // new Array() 패턴 체크
      if (
        nodePath.isNewExpression() &&
        t.isIdentifier(calleeNode, { name: 'Array' })
      ) {
        const args = nodePath.get('arguments');
        if (Array.isArray(args) && args.length > 0) {
          const firstArg = args[0];
          if (firstArg.isNumericLiteral()) {
            const arraySize = firstArg.node.value;
            if (arraySize > arrayThreshold) {
              return true;
            }
          }
        }
      }

      // Array.from() 체크
      if (
        nodePath.isCallExpression() &&
        t.isMemberExpression(calleeNode) &&
        t.isIdentifier(calleeNode.object, { name: 'Array' }) &&
        t.isIdentifier(calleeNode.property, { name: 'from' })
      ) {
        const args = nodePath.get('arguments');
        if (Array.isArray(args) && args.length > 0) {
          const firstArg = args[0];
          if (firstArg.isNumericLiteral()) {
            const arraySize = firstArg.node.value;
            if (arraySize > arrayThreshold) {
              return true;
            }
          }
        }
      }

      // 배열 메서드 체인 체크
      if (
        t.isMemberExpression(calleeNode) &&
        isArrayMethod(calleeNode.property as t.Expression)
      ) {
        const objectPath = nodePath.get('callee.object');
        if (Array.isArray(objectPath)) {
          for (const objPath of objectPath) {
            if (checkForArrayOperations(objPath)) {
              return true;
            }
          }
        } else if (checkForArrayOperations(objectPath)) {
          return true;
        }
      }
    }

    // Arrow Function이 배열 연산을 반환하는 경우
    if (nodePath.isArrowFunctionExpression()) {
      const body = nodePath.get('body');
      if (checkForArrayOperations(body)) {
        return true;
      }
    }

    return false;
  }

  // Helper 함수: 노드가 useMemo로 감싸졌는지 확인
  function isMemoized(nodePath: NodePath | null): boolean {
    if (!nodePath) return false;

    let currentPath: NodePath | null = nodePath;
    while (currentPath) {
      if (currentPath.isCallExpression()) {
        const callee = currentPath.get('callee');
        if (callee.isIdentifier({ name: 'useMemo' })) {
          return true;
        }
      }
      currentPath = currentPath.parentPath;
    }

    return false;
  }

  // Helper 함수: 배열 메서드 식별
  function isArrayMethod(propertyNode: t.Expression): boolean {
    return (
      t.isIdentifier(propertyNode) &&
      ['map', 'filter', 'reduce', 'forEach', 'fill'].includes(propertyNode.name)
    );
  }
}

function getArraySize(path: NodePath): number {
  if (path.isCallExpression()) {
    const callee = path.node.callee;

    // new Array() 패턴 체크
    if (t.isNewExpression(callee)) {
      if (t.isIdentifier(callee.callee) && callee.callee.name === 'Array') {
        const sizeArg = callee.arguments[0];
        if (t.isNumericLiteral(sizeArg)) {
          return sizeArg.value;
        }
      }
    }

    // map, filter 등의 메서드 체인 체크
    if (t.isMemberExpression(callee)) {
      const object = callee.object;
      if (t.isCallExpression(object)) {
        return getArraySize(path.get('callee.object') as NodePath);
      }
    }
  }

  return 0;
}

function findEventHandlers(path: NodePath): EventHandler[] {
  const handlers: EventHandler[] = [];

  // 모든 변수 선언을 순회
  path.traverse({
    VariableDeclarator(declaratorPath) {
      // 1. 핸들러 함수 식별

      const id = declaratorPath.get('id');
      if (!id.isIdentifier()) return;

      const handlerName = id.node.name;
      if (!handlerName.startsWith('handle') && !handlerName.startsWith('on'))
        return;

      // 2. 함수 정의 확인
      const init = declaratorPath.get('init');
      if (Array.isArray(init)) return;

      // 3. useCallback 확인
      const parentNode = declaratorPath.parentPath?.parentPath?.node;
      const isCallbackWrapped =
        t.isCallExpression(parentNode) &&
        t.isIdentifier(parentNode.callee) &&
        parentNode.callee.name === 'useCallback';

      if (!isCallbackWrapped) {
        // 4. JSX 속성으로 전달되는지 확인
        let isPassedToJSX = false;
        path.traverse({
          JSXAttribute(jsxAttrPath) {
            if (
              t.isJSXIdentifier(jsxAttrPath.node.name) &&
              jsxAttrPath.node.value &&
              t.isJSXExpressionContainer(jsxAttrPath.node.value) &&
              t.isIdentifier(jsxAttrPath.node.value.expression) &&
              jsxAttrPath.node.value.expression.name === handlerName
            ) {
              isPassedToJSX = true;
            }
          },
        });

        // 5. 핸들러가 JSX props로 전달되면 추가
        if (isPassedToJSX) {
          handlers.push({
            name: handlerName,
            type: 'custom',
            usesProps: true,
            usesState: true,
            hasCleanup: false,
          });
        }
      }
    },
  });

  return handlers;
}

function findMemoizedComponents(path: NodePath): ChildComponent[] {
  const components: ChildComponent[] = [];
  const processedComponents = new Set<string>();

  path.traverse({
    CallExpression(callPath) {
      const node = callPath.node;
      if (!t.isMemberExpression(node.callee)) return;

      const object = node.callee.object;
      const property = node.callee.property;

      if (
        t.isIdentifier(object) &&
        object.name === 'React' &&
        t.isIdentifier(property) &&
        property.name === 'memo'
      ) {
        const componentInfo = analyzeMemoizedComponent(callPath);
        if (componentInfo && !processedComponents.has(componentInfo.name)) {
          components.push(componentInfo);
          processedComponents.add(componentInfo.name);
        }
      }
    },
  });

  return components;
}

// 루프 복잡도 계산

function calculateLoopComplexity(path: NodePath): number {
  let complexity = 1;
  let nestedLoops = 0;

  path.traverse({
    'ForStatement|WhileStatement|DoWhileStatement'() {
      nestedLoops++;
    },
  });
  // 중첩 루프의 경우 지수적으로 복잡도 증가

  return complexity * Math.pow(2, nestedLoops);
}

function checkForStateChanges(path: NodePath): boolean {
  let found = false;

  path.traverse({
    CallExpression(callPath: NodePath<t.CallExpression>) {
      if (isStateUpdate(callPath)) {
        found = true;
      }
    },
  });

  return found;
}

// React.memo 컴포넌트 분석
function analyzeMemoizedComponent(
  path: NodePath<t.CallExpression>
): ChildComponent | null {
  const arg = path.node.arguments[0];
  if (
    !t.isIdentifier(arg) &&
    !t.isFunctionExpression(arg) &&
    !t.isArrowFunctionExpression(arg)
  ) {
    return null;
  }

  return {
    name: t.isIdentifier(arg) ? arg.name : 'AnonymousMemoComponent',
    isMemoized: true,
    receivedFunctions: findReceivedFunctions(path),
  };
}

// 컴포넌트가 받는 함수형 props 찾기
function findReceivedFunctions(path: NodePath): string[] {
  const functions: string[] = [];

  path.traverse({
    JSXAttribute(attrPath) {
      const value = attrPath.node.value;
      if (
        t.isJSXExpressionContainer(value) &&
        t.isIdentifier(value.expression) &&
        isFunctionType(value.expression, path)
      ) {
        functions.push((attrPath.node.name as t.JSXIdentifier).name);
      }
    },
  });

  return functions;
}

// 함수형 prop인지 체크
function isFunctionType(identifier: t.Identifier, path: NodePath): boolean {
  const binding = path.scope.getBinding(identifier.name);
  if (!binding) return false;

  const bindingPath = binding.path;
  return (
    bindingPath.isFunctionDeclaration() ||
    (bindingPath.isVariableDeclarator() &&
      (t.isFunctionExpression(bindingPath.node.init) ||
        t.isArrowFunctionExpression(bindingPath.node.init)))
  );
}

// 함수형 props 전달 체크
function checkForFunctionPropPassing(path: NodePath): boolean {
  let passesFunctions = false;

  path.traverse({
    JSXAttribute(attrPath) {
      const value = attrPath.node.value;
      if (!t.isJSXExpressionContainer(value)) return;

      const expression = value.expression;
      if (t.isJSXEmptyExpression(expression)) return;

      if (
        t.isFunction(expression) ||
        (t.isIdentifier(expression) && isFunctionType(expression, path))
      ) {
        const parentCall = getParentCallExpression(attrPath);
        if (!parentCall || !isHook(parentCall)) {
          passesFunctions = true;
        }
      }
    },
  });

  return passesFunctions;
}

// 상태 업데이트 체크
function checkForStateUpdates(path: NodePath): boolean {
  let hasStateUpdates = false;
  // useState 호출 추적을 위한 Set
  const stateSetters = new Set<string>();

  // 먼저 useState 호출을 찾아서 setter 함수들을 수집
  path.traverse({
    CallExpression(callPath) {
      const callee = callPath.node.callee;
      if (t.isIdentifier(callee) && callee.name === 'useState') {
        const parent = callPath.parentPath;
        if (
          parent?.isVariableDeclarator() &&
          t.isArrayPattern(parent.node.id)
        ) {
          const setter = parent.node.id.elements[1];
          if (t.isIdentifier(setter)) {
            stateSetters.add(setter.name);
          }
        }
      }
    },
  });

  // 그 다음 setter 함수들의 호출을 찾음
  path.traverse({
    CallExpression(callPath) {
      const callee = callPath.node.callee;
      if (t.isIdentifier(callee) && stateSetters.has(callee.name)) {
        hasStateUpdates = true;
      }
    },
    // setState 메서드 호출도 체크
    MemberExpression(memberPath) {
      if (
        t.isIdentifier(memberPath.node.property) &&
        memberPath.node.property.name === 'setState'
      ) {
        hasStateUpdates = true;
      }
    },
  });

  return hasStateUpdates;
}

// 부모 CallExpression 노드 가져오기
function getParentCallExpression(
  path: NodePath
): NodePath<t.CallExpression> | null {
  let current: NodePath | null = path;
  while (current) {
    if (current.isCallExpression()) {
      return current as NodePath<t.CallExpression>;
    }
    current = current.parentPath;
  }
  return null;
}

================
File: src/optimizer/rules/defaultRules.ts
================
import { ComponentAnalysis, OptimizationRule } from '../../types';

export const defaultRules: OptimizationRule[] = [
  // 1. useMemo 사용 제안 규칙
  {
    name: 'useMemoForExpensiveCalculations',
    description: 'Suggest using useMemo for expensive calculations',
    priority: 8,
    test: (analysis: ComponentAnalysis): boolean => {
      const hasOptimizedHandlers = analysis.hooks.some(
        (hook) => hook.type === 'useCallback' && hook.wrappedFunction
      );

      return (
        !hasOptimizedHandlers && // useCallback이 이미 있으면 제외
        (analysis.complexity.cyclomaticComplexity > 5 ||
          analysis.renderAnalysis.hasExpensiveCalculations ||
          analysis.renderAnalysis.hasExpensiveOperations)
      );
    },
    suggestion: (analysis: ComponentAnalysis): string => {
      const complexity = analysis.complexity.cyclomaticComplexity;
      return `
Component "${analysis.name}" contains expensive calculations that could benefit from memoization.
- Cyclomatic Complexity: ${complexity}
- Has Expensive Operations: ${analysis.renderAnalysis.hasExpensiveOperations}

Consider using useMemo to avoid unnecessary recalculations:

\`\`\`typescript
const memoizedValue = useMemo(() => {
  // Move your expensive calculation here
  return expensiveOperation(dependencies);
}, [/* Add your dependencies here */]);
\`\`\`
      `;
    },
  },

  // 2. useCallback 사용 제안 규칙
  {
    name: 'useCallbackForEventHandlers',
    description: 'Suggest using useCallback for event handlers',
    priority: 7,
    test: (analysis: ComponentAnalysis): boolean => {
      let checkBooles: boolean[] = [];
      // 1. props로 받은 함수 타입 분석
      const propsFunctions = analysis.props.filter(
        ({ type }) => type === 'function'
      );

      if (propsFunctions.length > 0) {
        propsFunctions.forEach(({ name: propName }) => {
          // 해당 props 함수가 사용되는 모든 위치 찾기
          const usages = analysis.renderAnalysis.eventHandlers.filter(
            (handler) => {
              // 핸들러 내부에서 props 함수 사용 여부 체크
              const handlerBody = handler.name; // 실제로는 함수 본문을 분석해야 함
              return !handlerBody.includes(propName);
            }
          );
          usages.forEach((usage) => {
            // 재가공된 함수인 경우 useCallback 확인
            const isWrappedWithCallback = analysis.hooks.some(
              (hook) =>
                hook.type === 'useCallback' &&
                hook.wrappedFunction === usage.name
            );
            if (!isWrappedWithCallback) {
              checkBooles.push(true);
            }
          });
        });
      }

      // 2. 컴포넌트 내부에서 선언된 모든 함수 검사
      const internalHandlers = analysis.renderAnalysis.eventHandlers.filter(
        (handler) => !propsFunctions.some((prop) => prop.name === handler.name)
      );
      // useCallback으로 감싸진 함수 이름들 목록
      const callbackWrappedFunctions = analysis.hooks
        .filter((hook) => hook.type === 'useCallback')
        .map((hook) => hook.wrappedFunction)
        .filter((name): name is string => name !== undefined);

      internalHandlers.forEach((handler) => {
        // handler.name이 useCallback으로 감싸진 함수 목록에 있는지 확인
        if (!callbackWrappedFunctions.includes(handler.name)) {
          checkBooles.push(true);
        }
      });
      return checkBooles.length > 0;
    },
    suggestion: (analysis: ComponentAnalysis): string => {
      const handlers = analysis.renderAnalysis.eventHandlers;
      return `
Component "${analysis.name}" has event handlers that should be memoized:
${handlers.map((h) => `- ${h.name}`).join('\n')}

Consider using useCallback:

\`\`\`typescript
const ${handlers[0]?.name || 'handleEvent'} = useCallback((event) => {
  // Your event handling logic
}, [/* dependencies */]);
\`\`\``;
    },
  },
];

================
File: src/optimizer/rules/index.ts
================
export * from './defaultRules';

================
File: src/optimizer/index.ts
================
export * from './rules';

================
File: src/rules/react-hooks-optimization.ts
================
import { parse } from '@babel/parser';
import template from '@babel/template';
import traverse, { NodePath } from '@babel/traverse';
import * as t from '@babel/types';
import { ESLintUtils, TSESLint, TSESTree } from '@typescript-eslint/utils';
import { analyzeComponent } from '../analyzer/componentAnalyzer';
import { defaultRules } from '../optimizer/rules';
import { AnalyzerConfig, ComponentAnalysis } from '../types';

type MessageIds = 'useMemoSuggestion' | 'useCallbackSuggestion';

interface RuleOptions {
  memoThreshold: {
    propsCount: number;
    renderCount: number;
  };
  performanceThreshold: {
    complexity: number;
    arraySize: number;
    computationWeight: number;
  };
}

const createRule = ESLintUtils.RuleCreator(
  (name) =>
    `https://github.com/sijinyu/auto_react_optimization/blob/main/docs/rules/${name}.md`
);

export const reactHooksOptimization = createRule<[RuleOptions], MessageIds>({
  name: 'react-hooks-optimization',
  meta: {
    type: 'suggestion',
    docs: {
      description: 'Suggests optimizations for React hooks and components',
    },
    hasSuggestions: true, // 수정 제안 포함
    fixable: 'code', // 자동 수정 가능
    messages: {
      useMemoSuggestion: '{{ description }}',
      useCallbackSuggestion: '{{ description }}',
    },
    schema: [
      {
        type: 'object',
        properties: {
          memoThreshold: {
            type: 'object',
            properties: {
              propsCount: { type: 'number' },
              renderCount: { type: 'number' },
            },
            required: ['propsCount', 'renderCount'],
          },
          performanceThreshold: {
            type: 'object',
            properties: {
              complexity: { type: 'number' },
              arraySize: { type: 'number' },
              computationWeight: { type: 'number' },
            },
            required: ['complexity', 'arraySize', 'computationWeight'],
          },
        },
        required: ['memoThreshold', 'performanceThreshold'],
        additionalProperties: false,
      },
    ],
  },

  defaultOptions: [
    {
      memoThreshold: {
        propsCount: 2,
        renderCount: 3,
      },
      performanceThreshold: {
        complexity: 5,
        arraySize: 100,
        computationWeight: 0.7,
      },
    },
  ],

  create(context, [options]) {
    console.log('Rule is running with options:', options); // 로그 추가

    const analyzerConfig: AnalyzerConfig = {
      memoThreshold: options.memoThreshold,
      performanceThreshold: options.performanceThreshold,
    };

    function convertToNodePath(node: TSESTree.Node): NodePath<t.Node> {
      const code = context.sourceCode.getText(node);
      const ast = parse(code, {
        sourceType: 'module',
        plugins: ['jsx', 'typescript'],
      });
      let resultPath: NodePath<t.Node> | null = null;

      traverse(ast, {
        enter(path) {
          if (path.node.type === node.type) {
            resultPath = path;
          }
        },
      });

      if (!resultPath) {
        throw new Error('Failed to convert ESTree node to Babel node');
      }

      return resultPath;
    }

    function createFix(
      fixer: TSESLint.RuleFixer,
      node: TSESTree.Node,
      ruleName: string,
      analysis: ComponentAnalysis,
      sourceCode: TSESLint.SourceCode
    ): TSESLint.RuleFix | null {
      switch (ruleName) {
        case 'useMemoForExpensiveCalculations':
          return createUseMemoFix(fixer, node, analysis, sourceCode);
        case 'useCallbackForEventHandlers':
          return createUseCallbackFix(fixer, node, sourceCode);
        default:
          return null;
      }
    }

    function createUseMemoFix(
      fixer: TSESLint.RuleFixer,
      node: TSESTree.Node,
      analysis: ComponentAnalysis,
      sourceCode: TSESLint.SourceCode
    ): TSESLint.RuleFix {
      const build = template.expression(`
        useMemo(() => { 
          return CALCULATION
        }, [DEPS])
      `);

      const newNode = build({
        CALCULATION: sourceCode.getText(node),
        DEPS: analysis.hooks.flatMap((h) => h.dependencies).join(', '),
      });

      return fixer.replaceText(node, sourceCode.getText(newNode as any));
    }

    function createUseCallbackFix(
      fixer: TSESLint.RuleFixer,
      node: TSESTree.Node,
      sourceCode: TSESLint.SourceCode
    ): TSESLint.RuleFix {
      return fixer.replaceText(node, sourceCode.getText(node as any));
    }

    return {
      'FunctionDeclaration, FunctionExpression, ArrowFunctionExpression'(
        node:
          | TSESTree.FunctionDeclaration
          | TSESTree.FunctionExpression
          | TSESTree.ArrowFunctionExpression
      ) {
        console.log('Found a function:', node.type); // 로그 추가

        try {
          const nodePath = convertToNodePath(node);
          const analysis = analyzeComponent(
            nodePath,
            context.filename,
            analyzerConfig
          );

          defaultRules.forEach((rule) => {
            console.log('Testing rule:', rule.name); // 로그 추가

            if (rule.test(analysis)) {
              console.log('Rule test passed:', rule.name); // 로그 추가

              const messageId = getRuleMessageId(rule.name);
              if (messageId) {
                console.log('Reporting issue with messageId:', messageId); // 로그 추가

                context.report({
                  node,
                  messageId,
                  data: {
                    description: rule.suggestion(analysis),
                  },
                  fix(fixer) {
                    return createFix(
                      fixer,
                      node,
                      rule.name,
                      analysis,
                      context.sourceCode
                    );
                  },
                });
              }
            }
          });
        } catch (error) {}
      },
    };
  },
});

function getRuleMessageId(ruleName: string): MessageIds | null {
  const messageIds: Record<string, MessageIds> = {
    useMemoForExpensiveCalculations: 'useMemoSuggestion',
    useCallbackForEventHandlers: 'useCallbackSuggestion',
  };
  return messageIds[ruleName] || null;
}

================
File: src/types/index.ts
================
// 기본 설정 타입
export interface AnalyzerConfig {
  memoThreshold: {
    propsCount: number; // props 개수 임계값
    renderCount: number; // 렌더링 횟수 임계값
  };
  performanceThreshold: {
    complexity: number; // 복잡도 임계값
    arraySize: number; // 배열 크기 임계값
    computationWeight: number; // 연산 가중치
  };
}

// 컴포넌트 분석 결과 타입
export interface ComponentAnalysis {
  name: string; // 컴포넌트 이름
  filePath: string; // 파일 경로
  props: PropInfo[]; // props 정보
  hooks: HookInfo[]; // hooks 사용 정보
  complexity: ComplexityMetrics; // 복잡도 메트릭
  renderAnalysis: RenderAnalysis; // 렌더링 분석
  dependencies: string[]; // 의존성 목록
}

export interface PropInfo {
  name: string;
  type: PropType;
  usageCount: number; // 사용 횟수
  isRequired: boolean; // 필수 여부
  updates: number; // 업데이트 횟수
}

export type PropType =
  | 'string'
  | 'number'
  | 'boolean'
  | 'function'
  | 'object'
  | 'array'
  | 'element'
  | 'node'
  | 'custom';

export interface HookInfo {
  name: string;
  type: HookType;
  dependencies: string[]; // 의존성 배열
  complexity: number; // hook 복잡도
  wrappedFunction?: string; // useCallback이 감싸고 있는 함수 이름
}

export type HookType =
  | 'useState'
  | 'useEffect'
  | 'useMemo'
  | 'useCallback'
  | 'useRef'
  | 'useContext'
  | 'useReducer'
  | 'custom';

// 복잡도 메트릭
export interface ComplexityMetrics {
  cyclomaticComplexity: number; // 순환 복잡도
  cognitiveComplexity: number; // 인지 복잡도
  linesOfCode: number; // 코드 라인 수
  dependencies: number; // 의존성 수
}

// 렌더링 분석
export interface RenderAnalysis {
  estimatedRenderCount: number; // 예상 렌더링 횟수
  hasExpensiveCalculations: boolean; // 비용이 많이 드는 계산 포함 여부
  hasExpensiveOperations: boolean; // 비용이 많이 드는 연산 포함 여부
  affectedByStateChanges: boolean; // 상태 변경에 영향받는지 여부
  eventHandlers: EventHandler[]; // 이벤트 핸들러 목록
  hasEventHandlers: boolean; // 이벤트 핸들러 존재 여부
  hasChildComponents: boolean; // 자식 컴포넌트 존재 여부
  memoizedComponents: ChildComponent[]; // 메모이제이션된 컴포넌트
  functionPropPassing: boolean; // 함수형 props 전달 여부
  hasStateUpdates: boolean; // 상태 업데이트 존재 여부
}

// 이벤트 핸들러
export interface EventHandler {
  name: string;
  type: 'click' | 'change' | 'submit' | 'custom';
  usesProps: boolean; // props 사용 여부
  usesState: boolean; // 상태 사용 여부
  hasCleanup: boolean; // 정리 함수 존재 여부
}

export interface ChildComponent {
  name: string;
  isMemoized: boolean; // 메모이제이션 여부
  receivedFunctions: string[]; // 전달받은 함수 목록
}

export interface OptimizationRule {
  name: string;
  description: string;
  priority: number;
  test: (analysis: ComponentAnalysis) => boolean;
  suggestion: (analysis: ComponentAnalysis) => string;
}

================
File: src/utils/analyzerUtils.ts
================
import { NodePath } from '@babel/traverse';
import * as t from '@babel/types';
import { PropInfo } from '../types';
// 1. Props 분석 관련
export function analyzeProps(path: NodePath): PropInfo[] {
  const props: PropInfo[] = [];
  const processedProps = new Set<string>();

  // 함수 매개변수에서 props 분석
  const params = path.get('params');
  if (Array.isArray(params)) {
    params.forEach((param) => {
      if (param.isObjectPattern()) {
        const properties = param.get('properties');
        if (Array.isArray(properties)) {
          properties.forEach((prop) => {
            if (prop.isObjectProperty()) {
              const key = prop.get('key');
              if (key.isIdentifier()) {
                const name = key.node.name;
                const isHandler =
                  name.startsWith('handle') || name.startsWith('on');

                if (!processedProps.has(name)) {
                  props.push({
                    name,
                    type: isHandler ? 'function' : 'custom',
                    usageCount: countPropUsage(path, name),
                    isRequired: !isOptionalProp(prop.node),
                    updates: countPropUpdates(path, name),
                  });
                  processedProps.add(name);
                }
              }
            }
          });
        }
      }
    });
  }

  return props;
}

// 4. 사용량 분석 관련
function countPropUsage(path: NodePath, propName: string): number {
  let count = 0;

  path.traverse({
    Identifier(idPath) {
      if (
        idPath.node.name === propName &&
        !idPath.parentPath?.isObjectProperty()
      ) {
        count++;
      }
    },
  });

  return count;
}

function countPropUpdates(path: NodePath, propName: string): number {
  let count = 0;

  path.traverse({
    AssignmentExpression(assignPath) {
      if (
        t.isIdentifier(assignPath.node.left) &&
        assignPath.node.left.name === propName
      ) {
        count++;
      }
    },
  });

  return count;
}

function isOptionalProp(prop: t.ObjectProperty): boolean {
  if (!t.isIdentifier(prop.value)) return false;

  const typeAnnotation = prop.value.typeAnnotation;
  if (!typeAnnotation || !t.isTSTypeAnnotation(typeAnnotation)) return false;

  const tsType = typeAnnotation.typeAnnotation;
  return (
    t.isTSUnionType(tsType) &&
    tsType.types.some(
      (type) =>
        t.isTSUndefinedKeyword(type) ||
        t.isTSNullKeyword(type) ||
        (t.isTSLiteralType(type) && t.isNullLiteral(type.literal))
    )
  );
}

================
File: src/utils/astUtils.ts
================
import { NodePath } from '@babel/traverse';
import * as t from '@babel/types';

export const HOOK_TYPES = {
  STATE: 'useState',
  EFFECT: 'useEffect',
  MEMO: 'useMemo',
  CALLBACK: 'useCallback',
  REF: 'useRef',
  CONTEXT: 'useContext',
  REDUCER: 'useReducer',
} as const;

export function getNode<T extends t.Node>(input: NodePath<T> | T): T {
  return input instanceof NodePath ? input.node : input;
}

// 3. Hook 관련 체크
export function isHook(
  input: NodePath<t.CallExpression> | t.CallExpression
): boolean {
  const node = getNode(input);
  return (
    t.isIdentifier(node.callee) &&
    node.callee.name.startsWith('use') &&
    node.callee.name[3] === node.callee.name[3].toUpperCase()
  );
}

export function isSpecificHook(
  input: NodePath<t.CallExpression> | t.CallExpression,
  hookName: string
): boolean {
  const node = getNode(input);
  return t.isIdentifier(node.callee) && node.callee.name === hookName;
}

export function getHookDependencies(
  input: NodePath<t.CallExpression> | t.CallExpression
): string[] {
  const node = getNode(input);
  const dependencies: string[] = [];
  const depsArg = node.arguments[1];

  if (t.isArrayExpression(depsArg)) {
    depsArg.elements.forEach((element) => {
      if (t.isIdentifier(element)) {
        dependencies.push(element.name);
      }
    });
  }

  return dependencies;
}

export function getComponentName(path: NodePath): string | null {
  if (path.isFunctionDeclaration() && path.node.id) {
    return path.node.id.name;
  }

  let parentNode = path.parentPath?.node;
  if (
    parentNode &&
    'id' in parentNode &&
    parentNode.id?.type === 'Identifier'
  ) {
    return parentNode.id.name;
  }

  // export default 케이스 처리
  const exportDefault = path.findParent((p) => p.isExportDefaultDeclaration());
  if (exportDefault) {
    const previous = exportDefault.getPrevSibling();
    if (previous.isVariableDeclaration()) {
      const declaration = previous.node.declarations[0];
      if (t.isIdentifier(declaration.id)) {
        return declaration.id.name;
      }
    }
  }

  return null; // 이름을 알 수 없는 경우 null 반환
}

================
File: src/utils/index.ts
================
export * from './astUtils';
export * from './analyzerUtils';

================
File: src/index.ts
================
import { reactHooksOptimization } from './rules/react-hooks-optimization';

module.exports = {
  rules: {
    'prefer-optimization': reactHooksOptimization,
  },
};

================
File: .babelrc
================
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "esmodules": true
        }
      }
    ],
    "@babel/preset-react",
    "@babel/preset-typescript"
  ]
}

================
File: .gitignore
================
.yarn/*
!.yarn/releases
!.yarn/plugins
.pnp.*
dist/
node_modules
.vscode

================
File: .npmignore
================
src/
__tests__/
examples/
.git/
.gitignore
.babelrc
jest.config.js
tsconfig.json
*.test.ts
README.md

================
File: jest.config.js
================
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/*.test.ts'],
  collectCoverageFrom: ['src/**/*.ts'],
  coveragePathIgnorePatterns: ['/node_modules/', '/dist/'],
};

================
File: package.json
================
{
  "name": "eslint-plugin-react-hooks-optimization",
  "version": "1.0.0",
  "description": "An ESLint plugin for React optimization suggestions like useMemo and useCallback.",
  "keywords": [
    "eslint",
    "react",
    "optimization",
    "useMemo",
    "useCallback"
  ],
  "files": [
    "dist"
  ],
  "main": "dist/src/index.js",
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src/**/*.ts",
    "format": "prettier --write src/**/*.ts"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/sijinyu/auto_react_optimization"
  },
  "author": "sijinyu <sijinyudev@gmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/sijinyu/auto_react_optimization/issues"
  },
  "homepage": "https://github.com/sijinyu/auto_react_optimization#readme",
  "exports": {
    ".": "./dist/src/index.js",
    "./package.json": "./package.json"
  },
  "peerDependencies": {
    "eslint": ">=7.0.0"
  },
  "dependencies": {},
  "devDependencies": {
    "@babel/cli": "^7.25.6",
    "@babel/core": "^7.25.2",
    "@babel/generator": "^7.25.6",
    "@babel/parser": "^7.26.2",
    "@babel/preset-env": "^7.25.4",
    "@babel/preset-react": "^7.24.7",
    "@babel/preset-typescript": "^7.24.7",
    "@babel/template": "^7.25.9",
    "@babel/traverse": "^7.25.9",
    "@babel/types": "^7.26.0",
    "@types/babel__traverse": "^7.20.6",
    "@types/jest": "^29.5.2",
    "@types/node": "^22.5.5",
    "@types/react": "^18.3.5",
    "@typescript-eslint/eslint-plugin": "^5.59.9",
    "@typescript-eslint/parser": "^5.62.0",
    "@typescript-eslint/types": "^8.12.2",
    "@typescript-eslint/utils": "^8.12.2",
    "eslint": "^8.42.0",
    "jest": "^29.5.0",
    "prettier": "^2.8.8",
    "react": "^18.3.1",
    "ts-jest": "^29.1.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.6.2"
  }
}

================
File: README.md
================
# 🚀 eslint-plugin-react-hooks-optimization 🔧

`eslint-plugin-react-hooks-optimization` is an ESLint plugin that recommends using `useMemo` and `useCallback` to optimize React projects and reduce unnecessary re-renders. This plugin detects performance issues in the codebase and provides specific recommendations and to help developers achieve optimal performance.

## ✨ Key Features

- 🧠 **useMemo Optimization**: Detects expensive calculations and suggests memoization
- 🖇️ **useCallback Optimization**: Identifies event handlers that should be memoized

## 📦 Installation

```bash
npm install eslint-plugin-react-hooks-optimization --save-dev
# or
yarn add eslint-plugin-react-hooks-optimization --dev
```

## Configuration

Add to your ESLint configuration file (.eslintrc.json):

```json
{
  "plugins": ["react-hooks-optimization"],
  "rules": {
    "react-hooks-optimization/prefer-optimization": [
      "warn",
      {
        "memoThreshold": {
          "propsCount": 2, // Minimum props count to suggest memoization
          "renderCount": 3 // Re-render count threshold
        },
        "performanceThreshold": {
          "complexity": 5, // Code complexity threshold
          "arraySize": 100, // Array size threshold
          "computationWeight": 0.7 // Computation cost weight
        }
      }
    ]
  }
}
```

## 🎯 Optimization Criteria

useMemo Suggestions
The plugin suggests useMemo when it detects:

Complex Calculations

Nested loops (exponential complexity)
High cyclomatic complexity (> 5)
Multiple mathematical operations

Large Array Operations

Arrays with more than 100 elements
Chained array methods (.map, .filter, .reduce)
Complex array transformations

```jsx
// Will suggest useMemo:
const processedData = data.map((item) => {
  return otherData.filter((other) => {
    return complex_calculation(item, other);
  });
});

const largeArray = new Array(1000).fill(0).map(complex_transformation);
```

useCallback Suggestions
The plugin suggests useCallback for functions that:

Are Passed as Props

Event handlers passed to child components
Callback functions used in effects

Contain State Updates

Functions that call setState
Functions that trigger effects

```jsx
// Will suggest useCallback:
const handleUpdate = () => {
  setCount((prev) => prev + 1);
  onDataChange(newValue); // prop function
};

<ChildComponent onUpdate={handleUpdate} />;
```

## 📋 Example Use Cases

Complex Data Processing

```jsx
// Before
function DataProcessor({ data }) {
  const processed = data
    .filter(complexFilter)
    .map(complexTransform)
    .reduce(complexReduce);

  return <Display data={processed} />;
}

// After (with optimization)
function DataProcessor({ data }) {
  const processed = useMemo(
    () =>
      data.filter(complexFilter).map(complexTransform).reduce(complexReduce),
    [data]
  );

  return <Display data={processed} />;
}
```

## 📜 License

MIT License

## 👨‍💻 Author

Created by Sijin

================
File: tsconfig.json
================
{
	"compilerOptions": {
		"outDir": "./dist",
		"rootDir": "./",
		"target": "ES6",
		"lib": ["es2015", "es2016", "es2017"],
		"module": "commonjs",
		"jsx": "react",
		"strict": true,
		"esModuleInterop": true,
		"skipLibCheck": true,
		"forceConsistentCasingInFileNames": true
	},
	"include": ["src/**/*", "bin/**/*", "optimizer/**/*"],
	"exclude": ["node_modules", "dist", "**/__tests__/*"]
}
